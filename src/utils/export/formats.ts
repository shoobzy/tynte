import { Palette } from '../../types/palette'
import { ExportOptions, ExportResult } from '../../types/export'
import { hexToRgb, hexToHsl, hexToOklch, formatRgb, formatHsl, formatOklch } from '../colour/conversions'

function sanitiseName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '_')
}

function formatColourValue(hex: string, format: ExportOptions['colorFormat']): string {
  switch (format) {
    case 'rgb':
      return formatRgb(hexToRgb(hex))
    case 'hsl':
      return formatHsl(hexToHsl(hex))
    case 'oklch':
      return formatOklch(hexToOklch(hex))
    case 'hex':
    default:
      return hex
  }
}

export function exportToJSON(
  palette: Palette,
  options: ExportOptions
): ExportResult {
  const output: Record<string, Record<string, string>> = {}

  for (const categoryColours of palette.categories) {
    if (categoryColours.colours.length === 0) continue

    output[categoryColours.category] = {}

    for (const colour of categoryColours.colours) {
      const value = formatColourValue(colour.hex, options.colorFormat)
      output[categoryColours.category][colour.name] = value
    }
  }

  return {
    content: JSON.stringify(output, null, 2),
    filename: `${palette.name.toLowerCase().replace(/\s+/g, '-')}-colours.json`,
    mimeType: 'application/json',
  }
}

export function exportToTypeScript(
  palette: Palette,
  options: ExportOptions
): ExportResult {
  const lines: string[] = []

  if (options.includeComments) {
    lines.push(`/**`)
    lines.push(` * ${palette.name}`)
    if (palette.description) {
      lines.push(` * ${palette.description}`)
    }
    lines.push(` * Generated by Tynte`)
    lines.push(` */`)
    lines.push('')
  }

  // Generate type definitions
  lines.push('export interface Colours {')

  for (const categoryColours of palette.categories) {
    if (categoryColours.colours.length === 0) continue

    lines.push(`  ${sanitiseName(categoryColours.category)}: {`)

    for (const colour of categoryColours.colours) {
      lines.push(`    ${sanitiseName(colour.name)}: string`)
    }

    lines.push('  }')
  }

  lines.push('}')
  lines.push('')

  // Generate the colours object
  lines.push('export const colours: Colours = {')

  for (const categoryColours of palette.categories) {
    if (categoryColours.colours.length === 0) continue

    lines.push(`  ${sanitiseName(categoryColours.category)}: {`)

    for (const colour of categoryColours.colours) {
      const value = formatColourValue(colour.hex, options.colorFormat)
      lines.push(`    ${sanitiseName(colour.name)}: '${value}',`)
    }

    lines.push('  },')
  }

  lines.push('} as const')
  lines.push('')

  // Generate flat exports
  lines.push('// Flat exports for convenience')

  for (const categoryColours of palette.categories) {
    for (const colour of categoryColours.colours) {
      const constName = `${sanitiseName(categoryColours.category).toUpperCase()}_${sanitiseName(colour.name).toUpperCase()}`
      const value = formatColourValue(colour.hex, options.colorFormat)
      lines.push(`export const ${constName} = '${value}'`)
    }
  }

  return {
    content: lines.join('\n'),
    filename: `${palette.name.toLowerCase().replace(/\s+/g, '-')}-colours.ts`,
    mimeType: 'text/typescript',
  }
}

export function exportToSwiftUI(
  palette: Palette,
  options: ExportOptions
): ExportResult {
  const lines: string[] = []

  lines.push('import SwiftUI')
  lines.push('')
  lines.push('extension Color {')

  for (const categoryColours of palette.categories) {
    if (categoryColours.colours.length === 0) continue

    if (options.includeComments) {
      lines.push(`    // MARK: - ${categoryColours.category}`)
    }

    for (const colour of categoryColours.colours) {
      const rgb = hexToRgb(colour.hex)
      const name = `${sanitiseName(categoryColours.category)}${colour.name.charAt(0).toUpperCase()}${sanitiseName(colour.name).slice(1)}`

      lines.push(`    static let ${name} = Color(`)
      lines.push(`        red: ${(rgb.r / 255).toFixed(3)},`)
      lines.push(`        green: ${(rgb.g / 255).toFixed(3)},`)
      lines.push(`        blue: ${(rgb.b / 255).toFixed(3)}`)
      lines.push('    )')
    }

    lines.push('')
  }

  lines.push('}')

  return {
    content: lines.join('\n'),
    filename: `${palette.name.replace(/\s+/g, '')}Colors.swift`,
    mimeType: 'text/x-swift',
  }
}

export function exportToKotlin(
  palette: Palette,
  options: ExportOptions
): ExportResult {
  const lines: string[] = []

  lines.push('package com.example.colors')
  lines.push('')
  lines.push('import androidx.compose.ui.graphics.Color')
  lines.push('')
  lines.push(`object ${palette.name.replace(/\s+/g, '')}Colors {`)

  for (const categoryColours of palette.categories) {
    if (categoryColours.colours.length === 0) continue

    if (options.includeComments) {
      lines.push(`    // ${categoryColours.category}`)
    }

    for (const colour of categoryColours.colours) {
      const hex = colour.hex.replace('#', '')
      const name = `${sanitiseName(categoryColours.category)}${colour.name.charAt(0).toUpperCase()}${sanitiseName(colour.name).slice(1)}`
      lines.push(`    val ${name} = Color(0xFF${hex.toUpperCase()})`)
    }

    lines.push('')
  }

  lines.push('}')

  return {
    content: lines.join('\n'),
    filename: `${palette.name.replace(/\s+/g, '')}Colors.kt`,
    mimeType: 'text/x-kotlin',
  }
}

export function exportToASE(palette: Palette): ExportResult {
  // Adobe Swatch Exchange format (simplified)
  // This generates a text representation; full binary ASE would require ArrayBuffer
  const lines: string[] = []

  lines.push(`// Adobe Swatch Exchange - ${palette.name}`)
  lines.push('// Import this into Adobe applications')
  lines.push('')

  for (const categoryColours of palette.categories) {
    for (const colour of categoryColours.colours) {
      const rgb = hexToRgb(colour.hex)
      lines.push(`${colour.name}: RGB ${rgb.r} ${rgb.g} ${rgb.b}`)
    }
  }

  return {
    content: lines.join('\n'),
    filename: `${palette.name.toLowerCase().replace(/\s+/g, '-')}.ase.txt`,
    mimeType: 'text/plain',
  }
}

export function exportToGPL(palette: Palette): ExportResult {
  // GIMP Palette format
  const lines: string[] = []

  lines.push('GIMP Palette')
  lines.push(`Name: ${palette.name}`)
  lines.push('Columns: 8')
  lines.push('#')

  for (const categoryColours of palette.categories) {
    for (const colour of categoryColours.colours) {
      const rgb = hexToRgb(colour.hex)
      lines.push(`${rgb.r.toString().padStart(3)} ${rgb.g.toString().padStart(3)} ${rgb.b.toString().padStart(3)} ${colour.name}`)
    }
  }

  return {
    content: lines.join('\n'),
    filename: `${palette.name.toLowerCase().replace(/\s+/g, '-')}.gpl`,
    mimeType: 'text/plain',
  }
}
